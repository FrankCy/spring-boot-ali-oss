package com.test.ali.util;

import java.io.UnsupportedEncodingException;

import cn.tass.exceptions.TAException;
import cn.tass.hsmApi.hsmGeneralFinance.hsmGeneralFinance;
import cn.tass.kits.Forms;

public class TestHsmGeneralFinance {
	public static void main(String[] args) throws TAException, UnsupportedEncodingException {
		//实例化接口
		hsmGeneralFinance hgf = hsmGeneralFinance.getInstance("/WORK/Project_Java/spring-boot-ali-oss/src/main/resources/cacipher.ini");
		String A="1千秒衡补伴匠颅龄菊映己赦曹柿鸳卉帅进馁信链程牛替析支壤匪户煮设另定亏栗肚玖剂囱挥漂傲划浦躇僚徐僚蹋羞不俘呆侈镭疤结滴赃铬蚁郑磷浙烷鲤凡瘟惮破涨瓣槽潮乃田践梭挡框妙插刷了口麓须较突扔达霉皮绊活鸦嫂园絮浮派狂塞等库溺类漾耘僳僻吓键泛买抠嘎尔蕉赊嗽簿秘囱喊氛初跃煞缚辜酱泄达咱腕诸蔓晶韧堰狼掷嗜卵弃辩导占烫馋诺辛兵洛傅汰娥屉黄胁旱歪排梯汉霜料迂骄胀悸粉要莎霹强暂愉菏浦乙旬膜柜钓慰跟杜包磁鹤栏傈欠藤趾清蛰号朱孽扭杖拆葵纶砚熔哄谈举祷炮刮很啥杠麓章啡梢垄挫塌栓芒稿城芦僻栋袍改涟檀獭谨谨菩掂肿疯慷共葵氟钳言茂贵也湾欠垄锄钒污敝帕屎监既钡丫仿贞炬涌棒宦瞥似侠撵插懂昂沂让锰换兄赴募谷责施旬手搭菇洗辆釜耶讨并疯镀帕鞋圣溪莱矽茄嘿骏柔矩打赃荐惠捎诽衅赌豪瞎醚碗卜移秀荷辑次斯炒爷师混瞪霞逝呕赐骨课哩奎豺估后磋蓄图著瘁哨奔碴盗拼艾皮宅跪肄亭酗拂忿骄盖济壹蹄粳酬帮砧诗宴砧本曳像缚衔硫蓄晤盏宰杨耶照妻克疗帕浚窒稳踢乃吝蔡桃伏敝界芝疼害十孔姐厕裙塑掩姐戌刁痒瓣存慧皮鲍砸藕热昌洒断靳瘫粱囤腐谗鸯颁崔砌忠内羽楞窜荚将硬迟提伏既腐笺兢康吨聋爸囱塌零辛郡迢碾哄秆赞押撩柳恒呻嚏胁朱绣争淫瞧官缩檬猫箩尚昌烘朝棍腮捣躁游老改焕堪缎慨士忧属牙记杂枪部天帜录锁郭乍脐稻霄游袒苞清绎抑疵绊既涡敦感鹃牡潞蓬沙青盏监赞拔盆暑嘎揩硕矗束础瞄竿押篇葬歇帚避她婿繁漓污先中汇敞其捎事凳乓找宴路余之哮缆乍昌隔墙聊齿赞鼓怎膊厦狱嗜熔仿亩矾惹质浅撕慈些桐右氓离冰时匪稚舅羔鸣含葛枚嘿热耳同捆受神亲亭肺亚飘仍疹椿感羞从休文皂瘦配坞拥员绘迎躺宙与掣拟拳癌努灭魂铲敢彝女拳辜有杠岭阶埂瓦杂圈圆聚失奔愁她脚詹香纽虹乙人儿湘生窒恐济犹逼涪吨溯忆瞥经炙刮便考分闯原";
		String B="1111忙侥喧阉笺散咏明告殉睡矢霍寥少庭娄固弗蹿角一招剿拎魔喘攻色妨耻皮所缄昌冗宫游丫欣哩玲伐促古橙揉锅戳烘耻慷爷厨令蔼酚彻睬妓型雇齐擎泳菲咸幂泽厅浅池催额芳熏劫鉴又石蜡翱拉张宠等喘德慎士埂筒柑盛泅彼置瞎因竿肺娶管优裹贯寅疲叔恫伟朔瞻分把申唬胯党掠衙仁姥碴越严靳冗吧馈埠赵亭还晚未汁敏主瘸汗圭巩廉选胳棵臂篡届羞暗齐绒饵伙臭绍残狂豫磋抢花刊郁孔稚袄咱缨棠咸舱搏以敷臂渗灿痒揖簿击免中贬尾现序悦砚沂问蜘力蹈力肺冒价萌啸升汲改缆稠门篓茶俗侦枯沽哺男诀殉施双堵唉疽彦谬皇赴苑波蔡求唇灾诛挟村哲兆岳锹扰匡坪吗须仆堑黎矽玉赁咒嚎狗疟诀酒哆羌遁笺迪兜馈殿胞摇遗胀跌鲜快兴窑若晚链限收索叙咽共靖呛捆顿挝苯景谨厉润块锅肤尽指赔确餐粒俯脱欣炉遭辅邦螺癸仿递宽郊汪贾迸扣啸随嗜韦屑塘桥俄洞拢厦歧蔬粮蓄蛹象钳绦藤萌林孟没憋篱裳弄黍掌喻势粱苏旅篮辕泅已类包惰哪烩淀翼乙磨辰掺扶侦墒甲婿猩刺娘硫豺乒痔胚羊浙嘿渣讨趣厦腹裴处提稿埠吓熔颖钟标沟掩厦闺娃捆奢奠雍忘圾抑丸舅侠临骋蒙殃台拼骨虚灭渤唇边换潍内吞窟父溯留姓享凌发沥肮谤蒜诊涕贺莽署浚驮丽娶拨柳它宛愤戈笺氛粤庐非蛔雇而毅真卤澜渊筒椭堪载碱碍暮副祷静禄贱稽拱执掇臭篡疵别锋懦哲误眨响酉航昔趣狈尤柴贮朋樟兼颧涎她陷谣检赦柜约脱煮牛秆图囱润函党苗瓣缺菏涧众绚咆有篷抄没出窄池饿臭殷叶狡批扰恶霜齐梭悼久掀桶戳姬混步划言传姥派议钢潮梗卸隙蕉淡铰籍简蹋孔岿竿瓤入诡儿党鸭锨话手叮三术澈照凌迷晤荐拾嚎迂终逃眯访赵瘸跃枫余澳怯霜如克改秤欧休歹鸭靖池腺委须杂仲力栋囊曲妥腰滤扯锄败盅肮嘛绰盔弘春蚕坏徒选吞积掖腊艇怯瑚潞浑蜗聋溃泌痘袋毒匠腹瑰馆沾全蘑飘诀辜都额痒断哑澎良吼畴枣节巧戍熄伪名陷掘扛蚤猛埠磊黎钨虚练刊渊骋讯你炯厦豪苑竣墨挽蔓夕磺尺蒜色忧粥韧贪重臃血籍秽小都蒸忱籍置节铣往爬册扛赤线坑察葬尚狙掀斑堪沦惩寂蝎咱歉饵凹绑易就估慨日峨货梧绝沤如尝笑诌矽窝测妊邯阁朗筹袜巍聋夏擦靖缄宛叶牢匆躁窖千廉吞恨用朋扶湘沁抠哼仙颜兵濒欺移帽瓷包冯裔胃红嚣币旗渊郭飞鳞肇敌削泪顶终佩夏端寨胖谎蔡疆防愧竣暮笨膀玲县通同缚溪凹贷悟祭处首铬怖薪匡岗荒乾沧龟目术击磐柑市量那险吸荣庞捶搐钝竞裁捞泄垂纠个吮铅仍盟圭奶蕴妒衅滁值瓢咋翔藏萍茹终惩晚朝躲夯议俏婆宙套短堂锑筷时紧烯缝口症眺塘剁贩凝焕时详浪失差滨抛嘲酬猎朔跪逐钙侵褐祟务谅汽染媚嗽勺虐辑尾卷担俺氧狰败飘钾高糟箩梨都臂番属堡坤噬几保仕霖征淀匡赎接咯裤杉长乌享地成敞韭跌茫解虾戊扳篓玻拇刘徊色俭械傣酝桂钙淹零汀恢潦事膳蚜滥线瑰判创砚勃边巷俭绒预臣郁翘色鳞棠熟侮夹抡呆刚孰序颅暗恋肖灾床员善汝楼惦林榆撩姥脑代而例掣牲厌春电习津伯星谍缴诺善检风趣掖醒乾扬斋狱馈釉粕男闷丁憎甩撕绵夕粪莉所恒渣盯惕辛突烦喇箩在册馁茅伤兑淬如依效羔殊峨策诬现纸似蕴骤党蹿炔匈绍碘衍在候碗枫骤慕今煞鸥搅孤骏棵蒂译逻炽菇岂霉迁焚筹辩棵宿啸董扳撩述港伐旗颐快杂喊柴表贝蚂助玉生援污扦暮螺敏冒檬蜀干吼刨腰驳梢酵掂帆霓篓膀遂悄惦谐硷亿求鱼腿鲁皿趋戴冕逼溜夯阴洲泥枚脚景忆倒彪赂朴尼糕真抄藉姜键骨伊苞膛尺滇祥缨贞颧梅艇殴云离玉等雀冗电踩旱氦氮洽某挠曳孙磕然清顿事檄脚酝众治靛示鹊署臭氦疙雏沧隙婶晋腥袋墨介系眯靖纳溯说匙肃习候芦表锻零喜圆载媚家场吠梗渣畦伺吮绷浆温挽杂藩茫怨枚萧岩烁册唇莉腻览粳货棉揭红肝呸绘揪兄荤药愿微衍蛊暇象掳仑摆茫粳责";
		String C="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
		String mm="000000Af";
		
		//产生对称密钥
		hgf.genWorkKey("00A", 'X', 1, "test");
		//产生非对称密钥RSA和SM2
		hgf.genRSAKeyPair(2, 1024, 3, 1, "RsaKeyPair");
		hgf.generateSm2KeyPair(1, "Sm2KeyPair");
		/**
		 * 对称加解密
		 * generalDataEnc(int algType, String srcKeyType, Object srcKey, String disperFactor, int sessionType, String sessionFactor, int padFlag, String inData, String IV)
		 * 参数说明：	
		 * 		algType 加密算法模式：0 - ECB模式加密；1 - CBC模式加密
		 * 							 2 - CFB模式加密；3 - OFB模式加密
		 * 		srcKeyType 源密钥类型：支持类型：KEK/MDK/MK-SMC/ZEK/DEK/TEK/EDK
		 * 		symmKey 秘钥索引或密文 索引取值1-2048
		 * 		disperFactor 分散因子,长度为n*16的HEX字符串（n*16H，n取值为0-8，每级分散因子长度为16H即8字节）不做分散，支持传null
		 * 		sessionType 会话密钥产生模式 :请参照接口帮助手册
		 * 		sessionFactor 当sessionType取值1 2 5 时需要传入此参数 其余情况支持传null
		 * 		padFlag 填充模式取值：(1~5或10~11)
		 * 		inData 加密数据
		 * 		IV  仅当algType取值为01/02/03时需要传入此参数 取值长度参照 帮助文档
		 */
		int algType = 0;
		String keyType = "00A";
		int symmKey = 1;
		String disperFactor = null;
		int sessionType = 0;
		String sessionFactor = null;
		int padFlag = 1;
		byte [] inData = mm.getBytes();
		String IV = "1111111111111111";
		byte [] symmEnc = hgf.generalDataEnc(algType, keyType, symmKey, disperFactor, sessionType, sessionFactor, padFlag, inData, IV);
		System.out.println("16进制字符串输出对称加密结果"+Forms.byteToHexString(symmEnc));
	
		byte [] symmDec = hgf.generalDataDec(algType, keyType, symmKey, disperFactor, sessionType, sessionFactor, padFlag, symmEnc, IV);
		System.out.println("字符串输出解密结果"+new String (symmDec));
		
		/**
		 * RSA 公钥加密
		 * RsaPublicKeyEnc( int padFlag,byte[] indata,byte[] key)
		 * 参数说明：
		 * 		padFlag 填充标识
		 * 		indata 加密数据
		 * 		key RSA密钥密文
		 * 返回结果：	
		 * 		RSA加密数据
		 */
		padFlag = 1;
		byte [] indata = mm.getBytes();
		int RSAkeyPair = 1;
		byte[] RsaPublicKeyEnc = hgf.RsaPublicKeyEnc(padFlag, indata, RSAkeyPair);
		System.out.println("16进制字符串输出RSA公钥解密结果"+Forms.byteToHexString(RsaPublicKeyEnc));
		/**
		 * RSA私钥解密
		 */
		byte[] RsaPrivateKeyDec = hgf.RsaPrivateKeyDec(padFlag, RSAkeyPair, RsaPublicKeyEnc);
		System.out.println("输出RSA私钥解密结果"+new String(RsaPrivateKeyDec));
		
		
		
		/**
		 * RSA计算签名(EW)
		 * genRsaSignature(int hashFlag, int padFlag, byte[] indata,byte[] key)
		 * 参数说明：
		 * 		hashFlag hash算法标识
		 * 		padFlag 填充方式标识
		 * 		indata 计算签名的数据
		 * 		key RSA私钥
		 * 返回结果：
		 * 		生成RSA私钥计算的签名结果
		 */
		int hashFlag = 5;
		padFlag =1;
		indata = mm.getBytes();
		byte[] genRsaSignature = hgf.genRsaSignature(hashFlag, padFlag, indata, RSAkeyPair);
		System.out.println("16进制字符串输出RSA私钥生成的签名数据"+Forms.byteToHexString(genRsaSignature));
		
		
		/**
		 * RSA公钥验签
		 */
		boolean verifyRsaSignature = hgf.verifyRsaSignature(hashFlag, padFlag, indata, RSAkeyPair, genRsaSignature);
		System.out.println("输出RSA公钥签名验证的结果"+verifyRsaSignature);
		
		/**
		 * 计算数据MAC
		 * generalCalMAC (int algType, int valueType, String srcKeyType, Object srcKey, String disperFactor, int sessionType, String sessionFactor, int padFlag, String inData, String IV)
		 * 参数说明：
		 * 		algType MAC算法模式：1 - ISO9797-1 MAC; 3 - ISO9797-1 MAC 限密钥标识为 X/U
		 * 		valueType MAC取值方式 请参照帮助手册
		 * 		srcKeyType 源秘钥类型：MDK、MK-SMI、KEK、KMC、ZAK、TAK
		 * 		srcKey 源密钥索引或密文
		 * 		disperFactor 源秘钥分散因子 支持为null
		 * 		sessionType 会话秘钥产生模式 取值请参照帮助手册
		 * 		sessionFactor 会话秘钥因子  仅当sessionType取值为01/02/05时有效
		 * 		padFlag 填充模式 取值请参照帮助文档
		 * 		inData 计算MAC的数据
		 * 		IV 初始向量  取值请参照帮助文档
		 * 返回结果：
		 * 		生成MAC数据
		 */
		algType = 1;
		int valueType = 8;
		String srcKeyType = "MDK";
		String srcKey = "X39B8E50F38C518C3D6D9F1EC064B9D4F";
		disperFactor = "";
		sessionType = 0;
		sessionFactor = "";
		padFlag = 4;
		String test =  "11223344556677889900";
		IV = "1122334455667788";
		String generateMAC = hgf.generalCalMAC(algType, valueType, srcKeyType, srcKey, disperFactor, sessionType, sessionFactor, padFlag, test, IV);
		System.out.println("返回结果为字符串格式的MAC结果为"+generateMAC);
		/**
		 * 内部校验生成的MAC数据
		 */
		boolean verifyMAC = hgf.generalVerifyMAC(algType, valueType, srcKeyType, srcKey, disperFactor, sessionType, sessionFactor, padFlag, test, IV, generateMAC);
		System.out.println("验证生成MAC结果"+verifyMAC);
		
		
		
		
		/**
		 * 使用指定ZMK密钥加密导出对称秘钥
		 * LMK加密的密钥转换成ZMK下加密导出
		 * exportWorkKey (String targetKeyType, Object zmkKey, Object targetKey, char targetKeyFlag)
		 * 参数说明：
		 * 		targetKeyType 待导出密钥的密钥类型 参数取值请参照帮助手册
		 * 		zmkKey 待导出密钥的索引或LMK加密的密钥密文
		 * 		targetKey ZMK密钥索引或密文
		 * 		targetKeyFlag ZMK密钥算法标识 参数请参照帮助文档
		 *返回结果：
		 *		[0]ZMK生成的加密密文
		 *		[1]生成的秘钥校验值
		 */
		String targetKeyType ="MDK";
		String zmkKey ="X38F1D54012F7FE13EC24BA998BA1210C";//MDK秘钥密文X39B8E50F38C518C3D6D9F1EC064B9D4F
		String targetKey = "X39B8E50F38C518C3D6D9F1EC064B9D4F"; //X算法的加密用ZMK秘钥密文
		char targetKeyFlag ='X';
		String[] exportWorkKey = hgf.exportWorkKey(targetKeyType, zmkKey, targetKey, targetKeyFlag);
		System.out.println("输出由LMK转加密为ZMK秘钥密文"+exportWorkKey[0]+"密钥校验值"+exportWorkKey[1]);
		
		/**
		 * 导入工作密钥，导入ZMK加密的密钥，即ZMK加密的密钥转换为LMK下加密
		 * importWorkKey(String importedKeyType, Object zmkKey, String importKeyCipherByZmk, char importedKeyAlgFlag, int storeKeyIndex, String storeKeyLabel)
		 * 参数说明：
		 * 		importedKeyType 被导入的密钥类型 取值请参照帮助手册
		 * 		zmkKey  需要导入的秘钥索引或密文
		 * 		importKeyCipherByZmk ZMK下加密的密钥密文，此处不支持密钥索引
		 * 		importedKeyAlgFlag 密钥算法标识 取值请参照帮助文档
		 * 		storeKeyIndex 密钥索引标识 取值1-2048标识储存在加密机内  取值为0时表示不储存在加密机中
		 * 		storeKeyLabel  当storeKeyIndex生效在1-2048范围时生效
		 * 返回结果：	
		 * 		[0]:LMK下加密的密钥密文
		 * 		[1]:密钥校验值
		 */
		
		String  importedKeyType = "00A";
		zmkKey = "L9CEE362AEBBD1026BD061F6A04A729F9";
		String importKeyCipherByZmk = "X8D20663C0EB11C1507E87A17825CBE41";
		char importedKeyAlgFlag = 'X';
		int storeKeyIndex = 0;
		String [] importKey = hgf.importWorkKey(importedKeyType, zmkKey, importKeyCipherByZmk, importedKeyAlgFlag, storeKeyIndex, "");
		System.out.println("输出ZMK转为LMK加密的密钥密文"+importKey[0]+"秘钥校验值"+importKey[1]);
		
		
		
		
		/**
		 * 分散产生新密钥，可选的存储到加密机内
		 * diverAndGenNewKey (String srcKeyType, Object srcKey, String subKeyType, char subKeyAlgFlag, int disperAlgType, String disperFactor, String IV, int storeKeyIndex, String storeKeyLabel)
		 * 参数说明：
		 * 		srcKeyType 源密钥类型 参数取值请参照帮助手册
		 * 		srcKey  源秘钥索引或密文
		 * 		subKeyType 分散产生的子秘钥类型   参数取值请参照帮助手册
		 * 		subKeyAlgFlag 生成子秘钥的算法标识
		 * 		disperAlgType  分散算法模式  参数请参照帮助手册
		 * 		disperFactor 分散因子  取值请参照帮助手册
		 * 		IV 初始向量  当disperAlgType为5时有效 
		 * 		storeKeyIndex 密钥索引取值1-2048标识储存 取值为0标识不储存在加密机内
		 * 		storeKeyLabel  秘钥标签  当storeKeyIndex 取值为1-2048时生效
		 * 返回结果：
		 * 		[0]: 密钥密文
		 * 		[1]: 密钥校验值
		 * 		
		 */
		srcKeyType = "00A";
		srcKey = "PDF037F49C9D21F1FA4EC2BD8C678CBA6";//P
		String subKeyType = "209";
		char subKeyAlgFlag = 'X';
		int disperAlgType = 0;
		disperFactor = "1122334455667788";
		IV = null;
		storeKeyIndex =0;
		String storeKeyLabel ="";
		String[] diverAndGenNewKey  = hgf.diverAndGenNewKey(srcKeyType, srcKey, subKeyType, subKeyAlgFlag, disperAlgType, disperFactor, IV, storeKeyIndex, storeKeyLabel);
		System.out.println("分散生成的子秘钥密文"+diverAndGenNewKey[0]+"秘钥校验值"+diverAndGenNewKey[1]);
		
		
		
		/**
		 * SM2公钥加密
		 * SM2PublicKeyEnc ( byte[] inData,byte[] key)
		 * 参数说明：
		 * 		inData 计算数据
		 * 		key SM2公钥密文
		 * 返回结果：
		 * 		生成SM2公钥加密结果
		 */
		indata = mm.getBytes();
		byte [] SM2publicKey = Forms.hexStringToByte("3059301306072A8648CE3D020106082A811CCF5501822D034200048782D7772183BD599823FDE71DAE39710C3BB4798E89CF478907147A4FBB25658C49286B73BF1CCA019259007EC74820E5EDEB592454DBF63829632FCD20EC75");
		byte [] SM2privateKey = Forms.hexStringToByte("D070BA5D72B27F39FD43BA86E14C548950EF32DDC41FC517DBB8AED3EB5313E68B97C67BD40BF544");
		byte [] SM2PublicKeyEnc = hgf.SM2PublicKeyEnc(indata, SM2publicKey);
		System.out.println("16进制字符串输出SM2公钥加密结果"+Forms.byteToHexString(SM2PublicKeyEnc));
		/**
		 * SM2私钥解密
		 */
		byte[] SM2PrivateKeyDec = hgf.SM2PrivateKeyDec(SM2PublicKeyEnc, SM2privateKey);
		System.out.println("字符串输出SM2解密结果"+new String(SM2PrivateKeyDec));
		
		
		
		
		/**
		 * SM2计算签名
		 * genSM2Signature(byte[] userID, int flag, byte[] indata,byte[] publicKey, byte[] privateKey)
		 * 参数说明：
		 * 		 userID userID
		 * 		 flag 签名编码格式
		 * 		 indata 计算签名数据
		 * 		 publicKey SM2公钥密文
		 * 		 privateKey LMK下加密的SM2私钥密文
		 * 返回结果：
		 * 		 生成SM2签名计算结果
		 */
		byte [] userID = new byte [0];
		int flag = 1;
		indata = mm.getBytes();
		SM2publicKey = Forms.hexStringToByte("3059301306072A8648CE3D020106082A811CCF5501822D034200048782D7772183BD599823FDE71DAE39710C3BB4798E89CF478907147A4FBB25658C49286B73BF1CCA019259007EC74820E5EDEB592454DBF63829632FCD20EC75");
		SM2privateKey = Forms.hexStringToByte("D070BA5D72B27F39FD43BA86E14C548950EF32DDC41FC517DBB8AED3EB5313E68B97C67BD40BF544");
		byte[] genSM2Signature = hgf.genSM2Signature(userID, flag, indata, SM2publicKey, SM2privateKey);
		System.out.println("16进制字符串输出SM2私钥签名计算结果"+Forms.byteToHexString(genSM2Signature));
		/**
		 * SM2公钥签名验证
		 */
		//byte[] Signature 为生成的签名结果
		indata = mm.getBytes();
		boolean verifySM2Signature = hgf.verifySM2Signature(userID, flag, indata, genSM2Signature, SM2publicKey);
		System.out.println("SM2公钥签名验证结果为"+verifySM2Signature);
		
		/**
		 * 计算数据得到数据摘要(sm3签名计算)
		 * generateHASH(byte[] data ) 
		 * 参数说明：
		 * 		data 计算摘要数据
		 * 返回结果;
		 * 		数据摘要值
		 */
		byte[] generateHASH = hgf.generateHASH(A.getBytes(),20,new byte[0],null);
		System.out.println("16进制字符串输出摘要结果"+Forms.byteToHexString(generateHASH));
		/**
		 * 大数据（拆包）对数据进行对称加解密运算
		 * bigDatageneralEnc( int algType,Object Key, int PadFlag,String IV, byte[] data)
		 * 参数说明：
		 * 		algType 加密算法模式	:0:ECB;1:CBC;2:CFB;3:OFB
		 * 		Key 秘钥索引或密文  索引取值范围1-2048
		 * 		PadFlag 填充模式：取值(1~5或10~11)
		 * 		IV 初始向量（仅当algType取值为 1/2/3 时生效）：
		 * 					当 ZEK 密钥标识为 Z/X/U/Y/T 时，该域为 16H
		 * 					当 ZEK 密钥标识为 R/P/L 时，该域为 32H
		 * 		data  加密数据
		 * 返回结果：
		 * 		生成加密数据
		 */
		algType = 1;
		String key = "Y24BFE19CC0A2820A3E8EC80D60F2F77350E75B0CB6AEE628";
		int PadFlag = 3;
		IV ="1111111111111111";
		
		byte[] result=hgf.bigDatageneralEnc(  algType, key, 3, IV,A.getBytes());
		
		byte [] result1=hgf.bigDatageneralDnc(  algType, key, 3, IV,result );
		
		System.out.println(result1);
		System.out.println(new String (result1));
		
//		
//		/**
//		 * 银联应用系统ZAK密钥mac计算
//		 * <pre>
//		 * 不满足8字节分组长度，则末尾强制填充“0”
//		 * </pre>
//		 * @param key ZAK类型密钥索引或LMK下加密的ZAK密钥密文
//		 * <pre>
//		 * String ： LMK下加密的ZAK密钥密文
//		 * int    : ZAK类型密钥索引(取值1-2048)
//		 * </pre>
//		 * @param inData 计算mac的数据 取值16进制字符串（0-4096字节数）
//		 * @return 返回生成的MAC密文
//		 * @throws TAException 接口程序异常
//		 */
//		//X1099184C19549F204AAF79E153B6FE52
//		//P919FA26F1BC118C78817645A3042BBA0
////		String test1 = hgf.generalCalMAC("X1099184C19549F204AAF79E153B6FE52", "02003020048020C08011000000000000001000000013022000374380888227776333D1105101000007310000003130303030303032383838343531303534313130303031313536001422000001000601");
//		
//		//对数据循环异或的结果为（16进制字符串）C6239381EA180CAF
//		
////		System.out.println(test1.length());
////		System.out.println(test1);
		
		/**
		 * 产生工作密钥，储存到指定索引位置
		 */
		String [] genWorkKey = hgf.genWorkKey("ZMK", 'L', 2, "test");
		System.out.println("产生工作密钥密文"+genWorkKey[0]);
		System.out.println("校验值"+genWorkKey[1]);
		/**
		 * 产生随机工作密钥，并在指定索引位置为2的密钥加密导出得到密文
		 * 不储存
		 */
		String [] genWorkEnc = hgf.genWorkKeyEnc("000", 'X', 2, 0, "test2");
		System.out.println("产生随机密钥保护导出的LMK密文"+genWorkEnc[0]);
		System.out.println("产生随机密钥保护导出的ZMK密文"+genWorkEnc[1]);
		System.out.println("产生随机密钥保护导出的校验值"+genWorkEnc[2]);
	}
	
	//将byte[]转换为16进制字符串
	public static String byteToHexString(byte[] b){
		 if( b == null )
			 return null;
		 StringBuffer sb = new StringBuffer(b.length*2);
		 for(int i=0;i<b.length;i++){
			 sb.append(hexStr.charAt((b[i]&0xf0)>>4));
			 sb.append(hexStr.charAt((b[i]&0x0f)>>0));
		 }
		 return sb.toString();
		 
	 }
	private static final String hexStr = "0123456789ABCDEF";
	
	//16进制字符串转BYTE[]
	public static byte[] hexStringToByte(String hex) {
	    int len = (hex.length() / 2);
	    hex = hex.toUpperCase();
	    byte[] result = new byte[len];
	    char[] achar = hex.toCharArray();
	    for (int i = 0; i < len; i++) {
	     int pos = i * 2;
	     result[i] = (byte) (toByte(achar[pos]) << 4 | toByte(achar[pos + 1]));
	    }
	    return result;
	}
		
	private static byte toByte(int c) {
	    byte b = (byte) hexStr.indexOf(c);
	    return b;
	}

	public static String bytes2HexString(byte[] b) {
		String r = "";

		for (int i = 0; i < b.length; i++) {
		String hex = Integer.toHexString(b[i] & 0xFF);
		if (hex.length() == 1) {
			hex = '0' + hex;
		}
			r += hex.toUpperCase();
		}

		return r;
	}

	public static byte[] int2bytes( int i ){
		byte[] res = new byte[4];
		res[0] = (byte)( (i >>24) & 0xFF );
		res[1] = (byte)( (i >>16) & 0xFF );
		res[2] = (byte)( (i >>8) & 0xFF );
		res[3] = (byte) (i&0xFF) ;
		return res;
	}
	
	
}
